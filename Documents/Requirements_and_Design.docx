Software Requirements and Design Document 

For
Group 12
Version 1.0

Authors: 
Andrei Desnica (aed21n)
Daniel Halterman (drh22a)
Kristian Moncada (km21v)
Nico Milette (njm21)

 
1.	Overview (5 points)
 Hotline Tallahassee is a top-down, round-based shooter game where players face waves of enemies while collecting upgrades to improve their character's abilities and weapons. Drawing inspiration from games like Hotline Miami and Call of Duty Zombies, this project offers fast-paced action with a simple, intuitive gameplay loop. Players will start with basic weapons and minimal enemies, but as they survive waves, the enemies become more challenging, and players can unlock upgrades to increase their odds of survival. The game aims to blend strategic elements, where players must choose the right upgrades, with intense, skill-based gameplay. The project is being developed on the Godot Engine, targeting the PC platform, with C# as the primary programming language.
2.	Functional Requirements (10 points)
1. The game will load properly with no errors or bugs.
Rationale: Having a non-functional game is pointless and accomplishes nothing.
2.	The system will allow the player to control the player character using WASD input for movement.
Rationale: Movement is fundamental to the game, as it directly impacts player control and gameplay experience.
3.	The system will enable the player character to aim in 360 degrees using the mouse cursor or joystick, allowing for omni-directional shooting.
Rationale: Accurate aiming is critical in top-down shooters, ensuring smooth and engaging combat mechanics.
4.	The system will allow the player character to shoot enemies using a starting weapon, with bullets or projectiles interacting with enemies.
Rationale: Shooting mechanics are central to the game’s combat experience and necessary for wave-based progression.
5.	The system will spawn waves of enemies at increasing difficulty levels as each wave progresses.
Rationale: The core gameplay loop revolves around defeating waves of enemies, making this a key feature.
6.	The system will allow the player character to dash in the direction of movement using the Shift or Space key for temporary evasion of enemy attacks.
Rationale: While enhancing player mobility and combat strategy, this feature is less critical to the core gameplay mechanics than movement and shooting.
7.	The system will display the player’s health and weapon status on-screen during gameplay.
Rationale: Vital feedback for the player to manage their health and weapon effectiveness during combat.
8.	The system will end the game and display a game-over screen when the player’s health reaches zero.
Rationale: Proper game termination and feedback on the player’s performance are critical to the gameplay loop.

3.	Non-functional Requirements (10 points)
1. Performance - The game should maintain a minimum frame rate of 60 frames per second (FPS) on target devices, even during high-action scenarios with multiple enemies on screen.
Rationale: A consistent frame rate is crucial for smooth gameplay, which directly impacts player experience and engagement.
2. Usability - The user interface (UI) should be intuitive and easy to navigate, with clear instructions and feedback for all actions.
Rationale: A user-friendly interface enhances player satisfaction and retention, making it easier for players to understand game mechanics and controls.
3. Reliability - The game should not crash or exhibit significant bugs during normal gameplay.
Rationale: High reliability is essential for player trust and enjoyment. Frequent crashes can lead to frustration and abandonment of the game.
4. Compatibility - The game should be compatible with a range of devices, including various PC configurations and operating systems, ensuring consistent performance across platforms.
Rationale: Broader compatibility allows more players to access the game, increasing its potential audience and overall success.
5. Maintainability - The code should be well documented and modular, allowing for easy updates and modifications to gameplay mechanics or features.
Rationale: Maintainable code is crucial for ongoing development and future updates, enabling the team to respond quickly to issues.
